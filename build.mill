//| mill-version: 1.1.0-RC1-native
//| mill-opts: ["-DPATH={$PATH}"]
//| mvnDeps:
//|   - com.goyeau::mill-scalafix_mill1:0.6.0
//|   - com.lihaoyi::mill-contrib-scoverage:1.1.0-RC1
//| mill-jvm-opts: ["-Xss10m"]

import com.goyeau.mill.scalafix.ScalafixModule
import mill.util.{VcsVersion, Tasks, Jvm}
import mill.contrib.scoverage.{ScoverageModule, ScoverageReport}

import mill.api.{Task, PathRef, DefaultTaskModule, Module, ModuleRef, Evaluator}
import mill.api.daemon.SelectMode
import mill.scalalib.{
  ScalaModule,
  NativeImageModule,
  DepSyntax,
  scalafmt,
  UnidocModule,
  TestModule,
  JavaModule,
  SonatypeCentralPublishModule
}
import mill.scalalib.publish.{Developer, PomSettings, License, VersionControl}
import mill.javalib.testrunner.TestResult
import mill.javalib.Lib
import mill.api.Task.{Named, Command}

import scala.sys.process.*
import scala.language.postfixOps
import java.io.PrintWriter
import os.Path
import mill.api.Task.Simple
import mill.scalalib.PlatformScalaModule
import mill.scalalib.PublishModule
import mill.scalanativelib.ScalaNativeModule
import mill.scalanativelib.api.LTO
import mill.scalanativelib.api.ReleaseMode
import java.lang.reflect.InvocationTargetException
import mill.javalib.PlatformModuleBase

trait ScairSettings extends ScalaModule with PublishModule:
  def scoverageVersion = Task { "2.4.1" }

  override def scalaVersion = "3.7.4"

  override def scalacOptions =
    super.scalacOptions() ++ Seq("-Wunused:imports", "-explain")

  override def artifactName = s"scair-${super.artifactName()}"

  override def publishVersion =
    VcsVersion.vcsState().format(untaggedSuffix = "-SNAPSHOT")

  override def pomSettings = PomSettings(
    description = artifactName(),
    organization = "io.github.edin-dal",
    url = "https://github.com/edin-dal/scair",
    licenses = Seq(License.`Apache-2.0`),
    versionControl = VersionControl.github(owner = "edin-dal", repo = "scair"),
    // TODO ?
    developers = Seq(
      Developer(
        id = "baymaks",
        name = "Maks Kret",
        url = "https://github.com/baymaks/"
      ),
      Developer(
        id = "papychacal",
        name = "Emilien Bauer",
        url = "https://github.com/PapyChacal/"
      )
    )
  )

trait JvmScairModule
    extends ScalafixModule
    with SonatypeCentralPublishModule
    with ScoverageModule
    with ScairSettings:

  trait ScairTests extends ScalaTests with TestModule.ScalaTest:
    override def mvnDeps = Seq(mvn"org.scalatest::scalatest::3.2.19")
    // This was necessary to cooperate with graalvm at time of writing.
    // Please remove if unit tests work fine without it in the future.
    override def testParallelism = false

  def outer = ModuleRef(this)

  // The normal behaviour, IIUC, is to compile the module at hand with coverage, and not
  // dependencies. This enforces that everything ScaIR is transitively compiled with
  // coverage when compiling a module with coverage.
  trait ScairScoverageData extends ScoverageData with ScairSettings:
    override def enableBsp = false

    override def transitiveModuleRunModuleDeps =
      super.transitiveModuleRunModuleDeps.map {
        case m: ScairModule => m.scoverage
        case m              => m
      }

    override def transitiveModuleCompileModuleDeps =
      super.transitiveModuleCompileModuleDeps.map {
        case m: ScairModule => m.scoverage
        case m              => m
      }

    trait ScairScoverageTests extends ScoverageTests with ScairTests:
      override def enableBsp = false
      override def moduleDir: Path = outer().test.moduleDir

    lazy val test = new ScairScoverageTests {}

  override lazy val scoverage: ScairScoverageData = new ScairScoverageData:
    override def mainClass = outer().mainClass

  lazy val test = new ScairTests {}

trait GraalScairModule extends ScairSettings with NativeImageModule:
  override def jvmId = "graalvm-community:24.0.2"

  // Remove "-Ob" (fast build) to revert to default "-O2" (highest optimization available
  // before paywall)
  override def nativeImageOptions =
    Seq("--no-fallback", "--initialize-at-build-time", "-Ob")

trait NativeScairModule(scairModule: ModuleRef[ScairModule]) extends ScairSettings with ScalaNativeModule
    with PlatformScalaModule:
  override def enableBsp = false
  override def scalaNativeVersion = "0.5.9"
  
  override def mvnDeps = scairModule().mvnDeps
  override def generatedSources: Simple[Seq[PathRef]] =
    scairModule().generatedSources
  override def mainClass: Simple[Option[String]] =
    scairModule().mainClass()

trait ScairModule extends JvmScairModule with GraalScairModule:
  def scairModule = ModuleRef(this)
  override def moduleDeps: Seq[ScairModule] = Seq()

  lazy val nativeOpt: NativeScairModule = new NativeScairModule(scairModule):
    override def nativeLTO: Simple[LTO] = LTO.Full
    override def releaseMode: Simple[ReleaseMode] = ReleaseMode.ReleaseFull
    override def moduleDeps = scairModule().moduleDeps.map(_.nativeOpt)

  lazy val native: NativeScairModule = new NativeScairModule(scairModule):
    override def nativeLTO: Simple[LTO] = LTO.None
    override def releaseMode: Simple[ReleaseMode] = ReleaseMode.Debug
    override def moduleDeps = scairModule().moduleDeps.map(_.native)

  override def sources: Simple[Seq[PathRef]] =
    super.sources() :+ PathRef(moduleDir / "build")

object `package` extends ScairSettings with ScoverageReport with UnidocModule:

  override def artifactName = "scair-all"

  override def moduleDeps = allChildren.collect {
    case m: ScairModule => m
  }

  override def unidocOptions =
    super.unidocOptions() ++ Seq("-snippet-compiler:compile")

  override def unidocVersion = Task { Some("0.6.0") }
  override def unidocDocumentTitle = Task { "ScaIR Unidoc" }

  def rootPath = moduleDir

  object utils extends ScairModule

  object macros extends ScairModule

  object core extends ScairModule:

    override def moduleDeps = Seq(utils, macros)

    override def mvnDeps = Seq(
      mvn"com.lihaoyi::fastparse::3.1.1"
    )

  object dialects extends ScairModule:

    def irdlSources = Task {
      Lib.findSourceFiles(sources(), Seq("irdl")).map(PathRef(_))
    }

    def scalaFiles = Task {
      val irdlFiles = irdlSources()

      irdlFiles.zipWithIndex.map { case (sourceFile, index) =>
        // Create a unique subdirectory for each IRDL file
        val destDir = Task.dest / s"irdl_$index"
        os.makeDir.all(destDir)

        Jvm.withClassLoader(classPath = core.runClasspath().map(_.path)) {
          classLoader =>
            val printerMethod = classLoader
              .loadClass("scair.core.irdl_printer.IRDLPrinter")
              .getMethod(
                "IRDLFileToScalaFile",
                classOf[String],
                classOf[String]
              )

            try
              printerMethod.invoke(
                null,
                sourceFile.path.toString,
                destDir.toString
              )
            catch
              case e: InvocationTargetException =>
                throw Exception(
                  s"Error during IRDL to Scala generation for ${sourceFile.path}:\n" +
                    e.getTargetException().getMessage()
                )
        }

        PathRef(destDir)
      }
    }

    override def generatedSources = scalaFiles()
    override def moduleDeps = Seq(core)

  object passes extends ScairModule:
    override def moduleDeps = Seq(dialects)

  object interpreter extends ScairModule:
    override def moduleDeps = Seq(dialects)

  object tools extends ScairModule:

    override def mvnDeps = Seq(
      mvn"com.github.scopt::scopt::4.1.0"
    )

    override def moduleDeps = Seq(core)

    object runTool extends ScairModule:
      override def moduleDeps = Seq(dialects, interpreter, tools)

      override def mainClass = Some("scair.tools.runTool.ScairRun")

    object opt extends ScairModule:
      override def moduleDeps = Seq(dialects, passes, tools)

      override def mainClass = Some("scair.tools.opt.ScairOpt")

  // Top-level commands and helpers

  def allScalaSources(evaluator: Evaluator) = Tasks(
    evaluator
      .resolveTasks(Seq("__.sources"), SelectMode.Multi)
      .get
      .asInstanceOf[Seq[Named[Seq[PathRef]]]]
  )

  def runAll(query: String, evaluator: Evaluator) = Task.sequence(
    evaluator
      .resolveTasks(Seq(query), SelectMode.Multi)
      .get
      .asInstanceOf[Seq[Named[Seq[TestResult]]]]
  )

  def allChildren = allChidrenRec(moduleDirectChildren)

  def allChidrenRec(children: Seq[Module]): Seq[Module] =
    children ++ children.flatMap(child =>
      allChidrenRec(child.moduleDirectChildren)
    )

  def scalafixAll(args: String*) = Command {
    Task.sequence(
      allChildren
        .flatMap {
          case m: ScairModule => Some(m.fix(args*))
          case _              => None
        }
    )()
  }

  // Run all formatting on all sources in the framework
  def formatAll(evaluator: Evaluator) = Command {
    scalafixAll()()
    scalafmt.ScalafmtModule.reformatAll(allScalaSources(evaluator))()
  }

  // Run all formatting *checks* on all sources in the framework
  def checkFormatAll(evaluator: Evaluator) = Command {
    scalafixAll("--check")()
    scalafmt.ScalafmtModule.checkFormatAll(allScalaSources(evaluator))()
  }

  // Define a testAll to run the full framework testing infrastructure
  def testAll(evaluator: Evaluator) = Command {
    runAll("__:ScairModule.test", evaluator)()
    filechecks.run()()
  }

  def scoverage(evaluator: Evaluator) = Command(exclusive = true) {
    runAll("__:ScairModule.scoverage.test", evaluator)()
    filechecks.scoverage.run()()
    xmlReportAll(evaluator)()
  }

  trait filechecks extends DefaultTaskModule:

    def scairOpt: Task[PathRef]
    def scairRun: Task[PathRef]

    // Make filechecks runnable directly as ./mill filechecks
    override def defaultTask(): String = "run"

    // Define a Mill command to run filechecks
    def run() = Task.Command(exclusive = true) {
      // Run lit, forwarding it the relevant scair-opt through the env var
      val litStatus = os
        .proc("lit", "tests/filecheck", "-v")
        .call(
          cwd = rootPath,
          propagateEnv = true,
          stdout = os.Inherit,
          stderr = os.Inherit,
          env = Map(
            ("SCAIR_OPT" -> scairOpt().path.toString),
            ("SCAIR_RUN" -> scairRun().path.toString)
          )
        )
      if litStatus.exitCode != 0 then sys.error(f"Filechecks failed")
    }

  object filechecks extends filechecks:
    override def scairOpt = tools.opt.launcher
    override def scairRun = tools.runTool.launcher

    object scoverage extends filechecks:
      override def scairOpt = tools.opt.scoverage.launcher
      override def scairRun = tools.runTool.scoverage.launcher

    object graal extends filechecks:
      override def scairOpt = tools.opt.nativeImage
      override def scairRun = tools.runTool.nativeImage

    object native extends filechecks:
      override def scairOpt = tools.opt.native.nativeLink
      override def scairRun = tools.runTool.native.nativeLink

    object nativeOpt extends filechecks:
      override def scairOpt = tools.opt.nativeOpt.nativeLink
      override def scairRun = tools.runTool.nativeOpt.nativeLink

