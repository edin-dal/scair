//| mill-version: 1.0.3-native
//| mill-opts: ["-DPATH={$PATH}"]
//| mvnDeps:
//|   - com.goyeau::mill-scalafix_mill1:0.6.0
//|   - com.lihaoyi::mill-contrib-scoverage:1.0.3

import com.goyeau.mill.scalafix.ScalafixModule
import mill.util.{VcsVersion, Tasks}
import mill.contrib.scoverage.{ScoverageModule, ScoverageReport}

import mill.api.{Task, PathRef, DefaultTaskModule, Module, ModuleRef, Evaluator}
import mill.api.daemon.SelectMode
import mill.scalalib.{ScalaModule, DepSyntax, scalafmt, UnidocModule, TestModule, JavaModule, SonatypeCentralPublishModule}
import mill.scalalib.publish.{Developer, PomSettings, License, VersionControl}
import mill.javalib.testrunner.TestResult
import mill.api.Task.{Named, Command}

import scala.sys.process._
import scala.language.postfixOps
import java.io.PrintWriter

trait ScairSettings extends ScalaModule with UnidocModule {

  def scoverageVersion = Task{"2.3.0"}
  override def scalaVersion = "3.7.1"
  override def scalacOptions = super.scalacOptions() ++ Seq("-Wunused:imports")
  override def unidocOptions = super.unidocOptions() ++ Seq("-snippet-compiler:compile")

  override def unidocVersion = Task{Some("0.5.0")}
  override def unidocDocumentTitle = Task{"ScaIR Unidoc"}

  override def unidocSourceFiles =
      (Seq(compile().classes) ++ Task.traverse(transitiveModuleDeps)(_.compile)().map(_.classes))
        .filter(pr => os.exists(pr.path))
        .flatMap(pr => os.walk(pr.path))
        .filter(_.ext == "tasty")
        .map(PathRef(_))
    }


trait ScairModule extends ScalafixModule with SonatypeCentralPublishModule with ScoverageModule with ScairSettings {

  override def artifactName = s"scair-${super.artifactName()}"

  override def pomSettings = PomSettings(
    description = artifactName(),
    organization = "io.github.edin-dal",
    url = "https://github.com/edin-dal/scair",
    licenses = Seq(License.`Apache-2.0`),
    versionControl = VersionControl.github(owner = "edin-dal", repo = "scair"),
    // TODO ?
    developers = Seq(
      Developer(
        id = "baymaks",
        name = "Maks Kret",
        url = "https://github.com/baymaks/"
      ),
      Developer(
        id = "papychacal",
        name = "Emilien Bauer",
        url = "https://github.com/PapyChacal/"
      )
    )
  )

  // The normal behaviour, IIUC, is to compile the module at hand with coverage, and not
  // dependencies. This enforces that everything ScaIR is transitively compiled with
  // coverage when compiling a module with coverage.
  trait ScairScoverageData extends ScoverageData {
    override def transitiveModuleRunModuleDeps = {
      super .transitiveModuleRunModuleDeps.map {
        case m: ScairModule => m.scoverage
        case m => m
      }
    }

    override def transitiveModuleCompileModuleDeps = {
      super .transitiveModuleCompileModuleDeps.map {
        case m: ScairModule => m.scoverage
        case m => m
      }
    }
  }
  
  override lazy val scoverage : ScairScoverageData = new ScairScoverageData {}

  override def publishVersion = VcsVersion.vcsState().format(untaggedSuffix = "-SNAPSHOT")

  object test extends ScoverageTests with TestModule.ScalaTest {
    override def mvnDeps = Seq(mvn"org.scalatest::scalatest:3.2.19")
  }
}

object `package` extends ScairSettings with ScoverageReport {

  override def moduleDeps = Seq(tools)

  def rootModule = ModuleRef(this)

  object core extends ScairModule {

    override def mvnDeps = Seq(
      mvn"com.lihaoyi::fastparse:3.1.0",
      mvn"com.github.scopt::scopt:4.1.0"
    )
  }

  object clair extends ScairModule {
    def moduleDeps = Seq(core)
  }

  object dialects extends ScairModule {
    def moduleDeps = Seq(clair)
  }

  object transformations extends ScairModule {
    def moduleDeps = Seq(dialects)
  }

  object tools extends ScairModule  {
    def moduleDeps = Seq(dialects, transformations)
    def mainClass = Some("ScairOpt")
  }

  // Top-level commands and helpers

  def allScalaSources(evaluator: Evaluator) = Tasks(evaluator.resolveTasks(Seq("__.sources"), SelectMode.Multi).get.asInstanceOf[Seq[Named[Seq[PathRef]]]])

  def runAllUnitTests(evaluator: Evaluator) = Task.sequence(evaluator.resolveTasks(Seq("__.test"), SelectMode.Multi).get.asInstanceOf[Seq[Named[Seq[TestResult]]]])
   
  def allChildren = allChidrenRec(moduleDirectChildren)
  def allChidrenRec(children: Seq[Module]): Seq[Module] = {
    children ++ children.flatMap(child => allChidrenRec(child.moduleDirectChildren))
  }

  def scalafixAll(args: String*) = Command(exclusive = true) {
    Task.sequence(allChildren
      .flatMap{case m : ScalafixModule => Some(m.fix(args*))
      case _ => None})()
    }

  // Run all formatting on all sources in the framework
  def formatAll(evaluator: Evaluator) = Command(exclusive = true) {
    scalafixAll()()
    scalafmt.ScalafmtModule.reformatAll(allScalaSources(evaluator))()
  }

  // Run all formatting *checks* on all sources in the framework
  def checkFormatAll(evaluator: Evaluator) = Command(exclusive = true) {
    scalafixAll("--check")()
    scalafmt.ScalafmtModule.checkFormatAll(allScalaSources(evaluator))()
  }

  // Define a testAll to run the full framework testing infrastructure
  def testAll(evaluator: Evaluator) = Command(exclusive = true) {
    runAllUnitTests(evaluator)()
    filechecks.run()()
  }


  object filechecks extends DefaultTaskModule {

    // Make filechecks runnable directly as ./mill filechecks
    override def defaultTask(): String = "run"
    // Define a Mill command to run filechecks
    def run() = Task.Command {
      // It depends on the runnable CLI
      tools.scoverage.launcher()

      // Get the directory root to use as lit's working directory
      val rootPath = rootModule().moduleDir
      // Run lit
      val litStatus = os.proc("lit", "tests/filecheck", "-v").call(cwd = rootPath, propagateEnv = true, stdout = os.Inherit, stderr = os.Inherit)
      if (litStatus.exitCode != 0) {
        sys.error(f"Filechecks failed")
      }
    }
  }
}
